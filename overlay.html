<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CrosshairPro Overlay</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            background: transparent;
            overflow: hidden;
            cursor: none;
            user-select: none;
            -webkit-user-select: none;
        }
        
        #crosshair-container {
            position: fixed;
            top: 50vh;
            left: 50vw;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 9999;
            transition: transform 0.1s ease-out;
        }
        
        #crosshair {
            position: relative;
            transform-origin: center;
        }
        
        .crosshair-line {
            position: absolute;
            background-color: #00ff00;
            transform-origin: center;
        }
        
        .crosshair-outline {
            position: absolute;
            border: 1px solid #000000;
            transform-origin: center;
        }
        
        .crosshair-dot {
            position: absolute;
            border-radius: 50%;
            background-color: #00ff00;
            transform: translate(-50%, -50%);
        }
        
        .crosshair-circle {
            position: absolute;
            border-radius: 50%;
            border: 2px solid #00ff00;
            transform: translate(-50%, -50%);
        }
        
        .crosshair-square {
            position: absolute;
            border: 2px solid #00ff00;
            transform: translate(-50%, -50%);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        .dynamic-color {
            animation: pulse 2s infinite;
        }
        
        /* Hotkey indicator */
        #hotkey-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        #hotkey-info.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="crosshair-container">
        <div id="crosshair"></div>
    </div>
    
    <div id="hotkey-info">
        <div>F1 - Toggle Overlay</div>
        <div>F2 - Hide Overlay</div>
    </div>

    <script>
        let currentSettings = {
            shape: 'cross',
            color: '#00ff00',
            size: 20,
            opacity: 80,
            thickness: 2,
            hasOutline: true,
            hasDot: false,
            dynamicColor: false,
            outlineColor: '#000000',
            outlineThickness: 1,
            gap: 0,
            length: 10,
            rotation: 0,
            blur: 0,
            shadowEnabled: false,
            shadowColor: '#000000',
            shadowBlur: 2,
            shadowOffsetX: 0,
            shadowOffsetY: 0
        };

        let hotkeys = [];
        let hotkeysEnabled = true;
        
        // Load hotkeys from localStorage
        function loadHotkeys() {
            try {
                const savedHotkeys = localStorage.getItem('crosshair-hotkeys');
                if (savedHotkeys) {
                    hotkeys = JSON.parse(savedHotkeys);
                    console.log('Loaded hotkeys:', hotkeys);
                }
                
                const savedEnabled = localStorage.getItem('hotkeys-enabled');
                if (savedEnabled !== null) {
                    hotkeysEnabled = JSON.parse(savedEnabled);
                    console.log('Hotkeys enabled:', hotkeysEnabled);
                }
            } catch (error) {
                console.error('Error loading hotkeys:', error);
                hotkeys = [];
                hotkeysEnabled = true;
            }
        }

        // Handle hotkey presses
        function handleHotkeyPress(event) {
            if (!hotkeysEnabled || hotkeys.length === 0) return;

            // Find matching hotkey
            const matchingHotkey = hotkeys.find(hotkey => {
                const keyMatch = hotkey.key.toLowerCase() === event.key.toLowerCase();
                const shiftMatch = hotkey.shift ? event.shiftKey : !event.shiftKey;
                const ctrlMatch = hotkey.ctrl ? event.ctrlKey : !event.ctrlKey;
                const altMatch = hotkey.alt ? event.altKey : !event.altKey;
                
                return keyMatch && shiftMatch && ctrlMatch && altMatch;
            });

            if (matchingHotkey) {
                console.log('Hotkey triggered:', matchingHotkey.name);
                updateCrosshair(matchingHotkey.settings);
                showHotkeyIndicator(matchingHotkey.name);
                event.preventDefault();
                event.stopPropagation();
            }
        }

        // Show hotkey indicator
        function showHotkeyIndicator(hotkeyName) {
            const indicator = document.getElementById('hotkey-info');
            indicator.innerHTML = `<div>Crosshair: ${hotkeyName}</div>`;
            indicator.classList.add('show');
            
            setTimeout(() => {
                indicator.classList.remove('show');
            }, 2000);
        }

        // Initialize hotkey system
        function initializeHotkeys() {
            loadHotkeys();
            
            // Add global keydown listener
            document.addEventListener('keydown', handleHotkeyPress, true);
            
            // Reload hotkeys periodically to sync with app changes
            setInterval(loadHotkeys, 5000);
        }

        function updateCrosshair(settings) {
            currentSettings = { ...currentSettings, ...settings };
            renderCrosshair();
        }

        function applyEffects(element, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY) {
            let effects = [];
            
            if (hasOutline) {
                effects.push(`0 0 0 ${outlineThickness}px ${outlineColor}`);
            }
            
            if (shadowEnabled) {
                effects.push(`${shadowOffsetX}px ${shadowOffsetY}px ${shadowBlur}px ${shadowColor}`);
            }
            
            if (effects.length > 0) {
                element.style.boxShadow = effects.join(', ');
            }
        }

        function applyEffectsForTriangles(element, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY) {
            let filters = [];
            
            if (hasOutline && outlineThickness > 0) {
                // Use multiple drop-shadows to simulate outline
                filters.push(`drop-shadow(${outlineThickness}px 0px 0px ${outlineColor})`);
                filters.push(`drop-shadow(-${outlineThickness}px 0px 0px ${outlineColor})`);
                filters.push(`drop-shadow(0px ${outlineThickness}px 0px ${outlineColor})`);
                filters.push(`drop-shadow(0px -${outlineThickness}px 0px ${outlineColor})`);
            }
            
            if (shadowEnabled) {
                filters.push(`drop-shadow(${shadowOffsetX}px ${shadowOffsetY}px ${shadowBlur}px ${shadowColor})`);
            }
            
            if (filters.length > 0) {
                element.style.filter = filters.join(' ');
            }
        }

        function renderCrosshair() {
            const container = document.getElementById('crosshair');
            container.innerHTML = '';

            const { 
                shape, color, size, opacity, thickness, hasOutline, hasDot, dynamicColor,
                outlineColor, outlineThickness, gap, length, rotation, blur, shadowEnabled,
                shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY, offsetX, offsetY
            } = currentSettings;
            
            // Set opacity
            container.style.opacity = opacity / 100;
            
            // Apply offset positioning
            const containerElement = document.getElementById('crosshair-container');
            if (offsetX || offsetY) {
                containerElement.style.transform = `translate(calc(-50% + ${offsetX || 0}px), calc(-50% + ${offsetY || 0}px))`;
            } else {
                containerElement.style.transform = 'translate(-50%, -50%)';
            }
            
            // Set rotation
            if (rotation) {
                container.style.transform = `rotate(${rotation}deg)`;
            } else {
                container.style.transform = '';
            }
            
            // Set blur
            if (blur > 0) {
                container.style.filter = `blur(${blur}px)`;
            } else {
                container.style.filter = '';
            }
            
            // Add dynamic color class
            if (dynamicColor) {
                container.classList.add('dynamic-color');
            } else {
                container.classList.remove('dynamic-color');
            }

            switch (shape) {
                case 'cross':
                    renderCross(container, color, size, thickness, hasOutline, gap, length, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
                    break;
                case 'circle':
                    renderCircle(container, color, size, thickness, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
                    break;
                case 'square':
                    renderSquare(container, color, size, thickness, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
                    break;
                case 'dot':
                    renderDot(container, color, size, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
                    break;
                case 't-shape':
                    renderTShape(container, color, size, thickness, hasOutline, gap, length, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
                    break;
                case 'plus':
                    renderPlus(container, color, size, thickness, hasOutline, gap, length, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
                    break;
                case 'diamond':
                    renderDiamond(container, color, size, thickness, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
                    break;
                case 'arrow':
                    renderArrow(container, color, size, thickness, hasOutline, gap, length, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
                    break;
                case 'x-shape':
                    renderXShape(container, color, size, thickness, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
                    break;
                case 'triangle':
                    renderTriangle(container, color, size, thickness, hasOutline, gap, length, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
                    break;
                case 'star':
                    renderStar(container, color, size, thickness, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
                    break;
                case 'crosshair-classic':
                    renderCrosshairClassic(container, color, size, thickness, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
                    break;
                case 'brackets':
                    renderBrackets(container, color, size, thickness, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
                    break;
                case 'hollow-circle':
                    renderHollowCircle(container, color, size, thickness, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
                    break;
            }

            // Add center dot if enabled
            if (hasDot && shape !== 'dot') {
                renderCenterDot(container, color, Math.max(2, thickness));
            }
        }

        function renderCross(container, color, size, thickness, hasOutline, gap = 0, length = 10, outlineColor = '#000000', outlineThickness = 1, shadowEnabled = false, shadowColor = '#000000', shadowBlur = 2, shadowOffsetX = 0, shadowOffsetY = 0) {
            // Use size as the total crosshair length
            const lineLength = size;
            const gapSize = gap || 0;
            
            if (gapSize > 0) {
                // Render with gap - 4 separate line segments
                // Each segment extends from the gap edge to the total size
                const segmentLength = (lineLength - gapSize) / 2;
                
                // Left horizontal segment
                const hLeft = document.createElement('div');
                hLeft.className = 'crosshair-line';
                hLeft.style.width = segmentLength + 'px';
                hLeft.style.height = thickness + 'px';
                hLeft.style.backgroundColor = color;
                hLeft.style.position = 'absolute';
                hLeft.style.top = '50%';
                hLeft.style.left = '50%';
                hLeft.style.transform = `translate(-${segmentLength + gapSize/2}px, -50%)`;
                applyEffects(hLeft, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
                container.appendChild(hLeft);
                
                // Right horizontal segment
                const hRight = document.createElement('div');
                hRight.className = 'crosshair-line';
                hRight.style.width = segmentLength + 'px';
                hRight.style.height = thickness + 'px';
                hRight.style.backgroundColor = color;
                hRight.style.position = 'absolute';
                hRight.style.top = '50%';
                hRight.style.left = '50%';
                hRight.style.transform = `translate(${gapSize/2}px, -50%)`;
                applyEffects(hRight, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
                container.appendChild(hRight);
                
                // Top vertical segment
                const vTop = document.createElement('div');
                vTop.className = 'crosshair-line';
                vTop.style.width = thickness + 'px';
                vTop.style.height = segmentLength + 'px';
                vTop.style.backgroundColor = color;
                vTop.style.position = 'absolute';
                vTop.style.top = '50%';
                vTop.style.left = '50%';
                vTop.style.transform = `translate(-50%, -${segmentLength + gapSize/2}px)`;
                applyEffects(vTop, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
                container.appendChild(vTop);
                
                // Bottom vertical segment
                const vBottom = document.createElement('div');
                vBottom.className = 'crosshair-line';
                vBottom.style.width = thickness + 'px';
                vBottom.style.height = segmentLength + 'px';
                vBottom.style.backgroundColor = color;
                vBottom.style.position = 'absolute';
                vBottom.style.top = '50%';
                vBottom.style.left = '50%';
                vBottom.style.transform = `translate(-50%, ${gapSize/2}px)`;
                applyEffects(vBottom, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
                container.appendChild(vBottom);
            } else {
                // Render without gap - 2 lines crossing at center
                // Horizontal line
                const hLine = document.createElement('div');
                hLine.className = 'crosshair-line';
                hLine.style.width = lineLength + 'px';
                hLine.style.height = thickness + 'px';
                hLine.style.backgroundColor = color;
                hLine.style.position = 'absolute';
                hLine.style.top = '50%';
                hLine.style.left = '50%';
                hLine.style.transform = 'translate(-50%, -50%)';
                applyEffects(hLine, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
                container.appendChild(hLine);

                // Vertical line
                const vLine = document.createElement('div');
                vLine.className = 'crosshair-line';
                vLine.style.width = thickness + 'px';
                vLine.style.height = lineLength + 'px';
                vLine.style.backgroundColor = color;
                vLine.style.position = 'absolute';
                vLine.style.top = '50%';
                vLine.style.left = '50%';
                vLine.style.transform = 'translate(-50%, -50%)';
                applyEffects(vLine, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
                container.appendChild(vLine);
            }
        }

        function renderCircle(container, color, size, thickness, hasOutline, outlineColor = '#000000', outlineThickness = 1, shadowEnabled = false, shadowColor = '#000000', shadowBlur = 2, shadowOffsetX = 0, shadowOffsetY = 0) {
            const circle = document.createElement('div');
            circle.className = 'crosshair-circle';
            circle.style.width = size + 'px';
            circle.style.height = size + 'px';
            circle.style.borderColor = color;
            circle.style.borderWidth = thickness + 'px';
            circle.style.position = 'absolute';
            circle.style.top = '50%';
            circle.style.left = '50%';
            
            applyEffects(circle, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            
            container.appendChild(circle);
        }

        function renderSquare(container, color, size, thickness, hasOutline, outlineColor = '#000000', outlineThickness = 1, shadowEnabled = false, shadowColor = '#000000', shadowBlur = 2, shadowOffsetX = 0, shadowOffsetY = 0) {
            const square = document.createElement('div');
            square.className = 'crosshair-square';
            square.style.width = size + 'px';
            square.style.height = size + 'px';
            square.style.borderColor = color;
            square.style.borderWidth = thickness + 'px';
            square.style.position = 'absolute';
            square.style.top = '50%';
            square.style.left = '50%';
            
            applyEffects(square, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            
            container.appendChild(square);
        }

        function renderDot(container, color, size, shadowEnabled = false, shadowColor = '#000000', shadowBlur = 2, shadowOffsetX = 0, shadowOffsetY = 0) {
            const dot = document.createElement('div');
            dot.className = 'crosshair-dot';
            dot.style.width = size + 'px';
            dot.style.height = size + 'px';
            dot.style.backgroundColor = color;
            dot.style.position = 'absolute';
            dot.style.top = '50%';
            dot.style.left = '50%';
            
            if (shadowEnabled) {
                dot.style.boxShadow = `${shadowOffsetX}px ${shadowOffsetY}px ${shadowBlur}px ${shadowColor}`;
            }
            
            container.appendChild(dot);
        }

        function renderTShape(container, color, size, thickness, hasOutline, gap = 0, length = 10, outlineColor = '#000000', outlineThickness = 1, shadowEnabled = false, shadowColor = '#000000', shadowBlur = 2, shadowOffsetX = 0, shadowOffsetY = 0) {
            const lineLength = size; // Use size parameter
            const gapSize = gap || 0; // Use gap parameter
            
            // Horizontal line (top)
            const hLine = document.createElement('div');
            hLine.className = 'crosshair-line';
            hLine.style.width = lineLength + 'px';
            hLine.style.height = thickness + 'px';
            hLine.style.backgroundColor = color;
            hLine.style.position = 'absolute';
            hLine.style.top = '50%';
            hLine.style.left = '50%';
            hLine.style.transform = `translate(-50%, -${gapSize/2 + thickness/2}px)`;
            applyEffects(hLine, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            
            // Vertical line (center down)
            const vLine = document.createElement('div');
            vLine.className = 'crosshair-line';
            vLine.style.width = thickness + 'px';
            vLine.style.height = lineLength * 0.8 + 'px';
            vLine.style.backgroundColor = color;
            vLine.style.position = 'absolute';
            vLine.style.top = '50%';
            vLine.style.left = '50%';
            vLine.style.transform = `translate(-50%, ${gapSize/2}px)`;
            applyEffects(vLine, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            
            container.appendChild(hLine);
            container.appendChild(vLine);
        }

        function renderPlus(container, color, size, thickness, hasOutline, gap = 0, length = 10, outlineColor = '#000000', outlineThickness = 1, shadowEnabled = false, shadowColor = '#000000', shadowBlur = 2, shadowOffsetX = 0, shadowOffsetY = 0) {
            const lineLength = size;
            const gapSize = gap > 0 ? gap : lineLength * 0.15; // Default gap if not specified
            const segmentLength = (lineLength - gapSize) / 2;
            
            // Horizontal lines (left and right)
            const hLeft = document.createElement('div');
            hLeft.className = 'crosshair-line';
            hLeft.style.width = segmentLength + 'px';
            hLeft.style.height = thickness + 'px';
            hLeft.style.backgroundColor = color;
            hLeft.style.position = 'absolute';
            hLeft.style.top = '50%';
            hLeft.style.right = '50%';
            hLeft.style.transform = `translate(${gapSize/2}px, -50%)`;
            applyEffects(hLeft, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            
            const hRight = document.createElement('div');
            hRight.className = 'crosshair-line';
            hRight.style.width = segmentLength + 'px';
            hRight.style.height = thickness + 'px';
            hRight.style.backgroundColor = color;
            hRight.style.position = 'absolute';
            hRight.style.top = '50%';
            hRight.style.left = '50%';
            hRight.style.transform = `translate(${gapSize/2}px, -50%)`;
            applyEffects(hRight, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            
            // Vertical lines (top and bottom)
            const vTop = document.createElement('div');
            vTop.className = 'crosshair-line';
            vTop.style.width = thickness + 'px';
            vTop.style.height = segmentLength + 'px';
            vTop.style.backgroundColor = color;
            vTop.style.position = 'absolute';
            vTop.style.bottom = '50%';
            vTop.style.left = '50%';
            vTop.style.transform = `translate(-50%, ${gapSize/2}px)`;
            applyEffects(vTop, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            
            const vBottom = document.createElement('div');
            vBottom.className = 'crosshair-line';
            vBottom.style.width = thickness + 'px';
            vBottom.style.height = segmentLength + 'px';
            vBottom.style.backgroundColor = color;
            vBottom.style.position = 'absolute';
            vBottom.style.top = '50%';
            vBottom.style.left = '50%';
            vBottom.style.transform = `translate(-50%, ${gapSize/2}px)`;
            applyEffects(vBottom, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            
            container.appendChild(hLeft);
            container.appendChild(hRight);
            container.appendChild(vTop);
            container.appendChild(vBottom);
        }

        function renderCenterDot(container, color, size) {
            const dot = document.createElement('div');
            dot.className = 'crosshair-dot';
            dot.style.width = size + 'px';
            dot.style.height = size + 'px';
            dot.style.backgroundColor = color;
            dot.style.top = '50%';
            dot.style.left = '50%';
            dot.style.zIndex = '10';
            container.appendChild(dot);
        }

        function renderDiamond(container, color, size, thickness, hasOutline, outlineColor = '#000000', outlineThickness = 1, shadowEnabled = false, shadowColor = '#000000', shadowBlur = 2, shadowOffsetX = 0, shadowOffsetY = 0) {
            const diamond = document.createElement('div');
            diamond.style.width = size + 'px';
            diamond.style.height = size + 'px';
            diamond.style.backgroundColor = 'transparent';
            diamond.style.border = `${thickness}px solid ${color}`;
            diamond.style.transform = 'translate(-50%, -50%) rotate(45deg)';
            diamond.style.position = 'absolute';
            diamond.style.top = '50%';
            diamond.style.left = '50%';
            
            applyEffects(diamond, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(diamond);
        }

        function renderArrow(container, color, size, thickness, hasOutline, gap = 0, length = 10, outlineColor = '#000000', outlineThickness = 1, shadowEnabled = false, shadowColor = '#000000', shadowBlur = 2, shadowOffsetX = 0, shadowOffsetY = 0) {
            const triangleSize = size || length; // Use size parameter correctly
            const gapSize = gap || 3;
            
            // Top triangle (pointing down)
            const topTriangle = document.createElement('div');
            topTriangle.style.width = '0';
            topTriangle.style.height = '0';
            topTriangle.style.borderLeft = `${triangleSize/2}px solid transparent`;
            topTriangle.style.borderRight = `${triangleSize/2}px solid transparent`;
            topTriangle.style.borderTop = `${triangleSize}px solid ${color}`;
            topTriangle.style.position = 'absolute';
            topTriangle.style.top = '50%';
            topTriangle.style.left = '50%';
            topTriangle.style.transform = `translate(-50%, -${triangleSize + gapSize}px)`;
            applyEffectsForTriangles(topTriangle, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(topTriangle);
            
            // Bottom triangle (pointing up)
            const bottomTriangle = document.createElement('div');
            bottomTriangle.style.width = '0';
            bottomTriangle.style.height = '0';
            bottomTriangle.style.borderLeft = `${triangleSize/2}px solid transparent`;
            bottomTriangle.style.borderRight = `${triangleSize/2}px solid transparent`;
            bottomTriangle.style.borderBottom = `${triangleSize}px solid ${color}`;
            bottomTriangle.style.position = 'absolute';
            bottomTriangle.style.top = '50%';
            bottomTriangle.style.left = '50%';
            bottomTriangle.style.transform = `translate(-50%, ${gapSize}px)`;
            applyEffectsForTriangles(bottomTriangle, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(bottomTriangle);
            
            // Left triangle (pointing right)
            const leftTriangle = document.createElement('div');
            leftTriangle.style.width = '0';
            leftTriangle.style.height = '0';
            leftTriangle.style.borderTop = `${triangleSize/2}px solid transparent`;
            leftTriangle.style.borderBottom = `${triangleSize/2}px solid transparent`;
            leftTriangle.style.borderLeft = `${triangleSize}px solid ${color}`;
            leftTriangle.style.position = 'absolute';
            leftTriangle.style.top = '50%';
            leftTriangle.style.left = '50%';
            leftTriangle.style.transform = `translate(-${triangleSize + gapSize}px, -50%)`;
            applyEffectsForTriangles(leftTriangle, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(leftTriangle);
            
            // Right triangle (pointing left)
            const rightTriangle = document.createElement('div');
            rightTriangle.style.width = '0';
            rightTriangle.style.height = '0';
            rightTriangle.style.borderTop = `${triangleSize/2}px solid transparent`;
            rightTriangle.style.borderBottom = `${triangleSize/2}px solid transparent`;
            rightTriangle.style.borderRight = `${triangleSize}px solid ${color}`;
            rightTriangle.style.position = 'absolute';
            rightTriangle.style.top = '50%';
            rightTriangle.style.left = '50%';
            rightTriangle.style.transform = `translate(${gapSize}px, -50%)`;
            applyEffectsForTriangles(rightTriangle, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(rightTriangle);
        }

        function renderXShape(container, color, size, thickness, hasOutline, outlineColor = '#000000', outlineThickness = 1, shadowEnabled = false, shadowColor = '#000000', shadowBlur = 2, shadowOffsetX = 0, shadowOffsetY = 0) {
            // Diagonal line 1 (top-left to bottom-right)
            const line1 = document.createElement('div');
            line1.style.width = Math.sqrt(2) * size + 'px';
            line1.style.height = thickness + 'px';
            line1.style.backgroundColor = color;
            line1.style.transform = 'translate(-50%, -50%) rotate(45deg)';
            line1.style.position = 'absolute';
            line1.style.top = '50%';
            line1.style.left = '50%';
            applyEffects(line1, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(line1);
            
            // Diagonal line 2 (top-right to bottom-left)
            const line2 = document.createElement('div');
            line2.style.width = Math.sqrt(2) * size + 'px';
            line2.style.height = thickness + 'px';
            line2.style.backgroundColor = color;
            line2.style.transform = 'translate(-50%, -50%) rotate(-45deg)';
            line2.style.position = 'absolute';
            line2.style.top = '50%';
            line2.style.left = '50%';
            applyEffects(line2, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(line2);
        }

        function renderTriangle(container, color, size, thickness, hasOutline, gap = 0, length = 10, outlineColor = '#000000', outlineThickness = 1, shadowEnabled = false, shadowColor = '#000000', shadowBlur = 2, shadowOffsetX = 0, shadowOffsetY = 0) {
            const triangleSize = size || length; // Use size parameter correctly
            const gapSize = gap || 3;
            
            // Similar to arrow but triangles point towards center
            // Top triangle (pointing towards center/down)
            const topTriangle = document.createElement('div');
            topTriangle.style.width = '0';
            topTriangle.style.height = '0';
            topTriangle.style.borderLeft = `${triangleSize/2}px solid transparent`;
            topTriangle.style.borderRight = `${triangleSize/2}px solid transparent`;
            topTriangle.style.borderTop = `${triangleSize}px solid ${color}`;
            topTriangle.style.position = 'absolute';
            topTriangle.style.top = '50%';
            topTriangle.style.left = '50%';
            topTriangle.style.transform = `translate(-50%, -${gapSize + triangleSize}px)`;
            applyEffectsForTriangles(topTriangle, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(topTriangle);
            
            // Bottom triangle (pointing towards center/up)
            const bottomTriangle = document.createElement('div');
            bottomTriangle.style.width = '0';
            bottomTriangle.style.height = '0';
            bottomTriangle.style.borderLeft = `${triangleSize/2}px solid transparent`;
            bottomTriangle.style.borderRight = `${triangleSize/2}px solid transparent`;
            bottomTriangle.style.borderBottom = `${triangleSize}px solid ${color}`;
            bottomTriangle.style.position = 'absolute';
            bottomTriangle.style.top = '50%';
            bottomTriangle.style.left = '50%';
            bottomTriangle.style.transform = `translate(-50%, ${gapSize}px)`;
            applyEffectsForTriangles(bottomTriangle, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(bottomTriangle);
            
            // Left triangle (pointing towards center/right)
            const leftTriangle = document.createElement('div');
            leftTriangle.style.width = '0';
            leftTriangle.style.height = '0';
            leftTriangle.style.borderTop = `${triangleSize/2}px solid transparent`;
            leftTriangle.style.borderBottom = `${triangleSize/2}px solid transparent`;
            leftTriangle.style.borderLeft = `${triangleSize}px solid ${color}`;
            leftTriangle.style.position = 'absolute';
            leftTriangle.style.top = '50%';
            leftTriangle.style.left = '50%';
            leftTriangle.style.transform = `translate(-${gapSize + triangleSize}px, -50%)`;
            applyEffectsForTriangles(leftTriangle, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(leftTriangle);
            
            // Right triangle (pointing towards center/left)
            const rightTriangle = document.createElement('div');
            rightTriangle.style.width = '0';
            rightTriangle.style.height = '0';
            rightTriangle.style.borderTop = `${triangleSize/2}px solid transparent`;
            rightTriangle.style.borderBottom = `${triangleSize/2}px solid transparent`;
            rightTriangle.style.borderRight = `${triangleSize}px solid ${color}`;
            rightTriangle.style.position = 'absolute';
            rightTriangle.style.top = '50%';
            rightTriangle.style.left = '50%';
            rightTriangle.style.transform = `translate(${gapSize}px, -50%)`;
            applyEffectsForTriangles(rightTriangle, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(rightTriangle);
        }

        function renderStar(container, color, size, thickness, hasOutline, outlineColor = '#000000', outlineThickness = 1, shadowEnabled = false, shadowColor = '#000000', shadowBlur = 2, shadowOffsetX = 0, shadowOffsetY = 0) {
            // Create SVG star shape
            const star = document.createElement('div');
            star.style.width = size + 'px';
            star.style.height = size + 'px';
            star.style.position = 'absolute';
            star.style.top = '50%';
            star.style.left = '50%';
            star.style.transform = 'translate(-50%, -50%)';
            
            // Create star using CSS clip-path
            star.style.backgroundColor = color;
            star.style.clipPath = 'polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)';
            
            applyEffects(star, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(star);
        }

        function renderCrosshairClassic(container, color, size, thickness, hasOutline, outlineColor = '#000000', outlineThickness = 1, shadowEnabled = false, shadowColor = '#000000', shadowBlur = 2, shadowOffsetX = 0, shadowOffsetY = 0) {
            const classicGap = 3;
            const lineLength = size;
            
            // Similar to cross but with fixed small gap
            const segmentLength = (lineLength - classicGap) / 2;
            
            // Top vertical segment
            const vTop = document.createElement('div');
            vTop.style.width = thickness + 'px';
            vTop.style.height = segmentLength + 'px';
            vTop.style.backgroundColor = color;
            vTop.style.position = 'absolute';
            vTop.style.top = '50%';
            vTop.style.left = '50%';
            vTop.style.transform = `translate(-50%, -${segmentLength + classicGap/2}px)`;
            applyEffects(vTop, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(vTop);
            
            // Bottom vertical segment
            const vBottom = document.createElement('div');
            vBottom.style.width = thickness + 'px';
            vBottom.style.height = segmentLength + 'px';
            vBottom.style.backgroundColor = color;
            vBottom.style.position = 'absolute';
            vBottom.style.top = '50%';
            vBottom.style.left = '50%';
            vBottom.style.transform = `translate(-50%, ${classicGap/2}px)`;
            applyEffects(vBottom, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(vBottom);
            
            // Left horizontal segment
            const hLeft = document.createElement('div');
            hLeft.style.width = segmentLength + 'px';
            hLeft.style.height = thickness + 'px';
            hLeft.style.backgroundColor = color;
            hLeft.style.position = 'absolute';
            hLeft.style.top = '50%';
            hLeft.style.left = '50%';
            hLeft.style.transform = `translate(-${segmentLength + classicGap/2}px, -50%)`;
            applyEffects(hLeft, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(hLeft);
            
            // Right horizontal segment
            const hRight = document.createElement('div');
            hRight.style.width = segmentLength + 'px';
            hRight.style.height = thickness + 'px';
            hRight.style.backgroundColor = color;
            hRight.style.position = 'absolute';
            hRight.style.top = '50%';
            hRight.style.left = '50%';
            hRight.style.transform = `translate(${classicGap/2}px, -50%)`;
            applyEffects(hRight, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(hRight);
        }

        function renderBrackets(container, color, size, thickness, hasOutline, outlineColor = '#000000', outlineThickness = 1, shadowEnabled = false, shadowColor = '#000000', shadowBlur = 2, shadowOffsetX = 0, shadowOffsetY = 0) {
            const bracketSize = size * 0.7;
            const lineLength = size * 0.3;
            
            // Top-left bracket
            const tlVertical = document.createElement('div');
            tlVertical.style.width = thickness + 'px';
            tlVertical.style.height = lineLength + 'px';
            tlVertical.style.backgroundColor = color;
            tlVertical.style.position = 'absolute';
            tlVertical.style.top = '50%';
            tlVertical.style.left = '50%';
            tlVertical.style.transform = `translate(-${bracketSize}px, -${bracketSize}px)`;
            applyEffects(tlVertical, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(tlVertical);
            
            const tlHorizontal = document.createElement('div');
            tlHorizontal.style.width = lineLength + 'px';
            tlHorizontal.style.height = thickness + 'px';
            tlHorizontal.style.backgroundColor = color;
            tlHorizontal.style.position = 'absolute';
            tlHorizontal.style.top = '50%';
            tlHorizontal.style.left = '50%';
            tlHorizontal.style.transform = `translate(-${bracketSize}px, -${bracketSize}px)`;
            applyEffects(tlHorizontal, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(tlHorizontal);
            
            // Top-right bracket
            const trVertical = document.createElement('div');
            trVertical.style.width = thickness + 'px';
            trVertical.style.height = lineLength + 'px';
            trVertical.style.backgroundColor = color;
            trVertical.style.position = 'absolute';
            trVertical.style.top = '50%';
            trVertical.style.left = '50%';
            trVertical.style.transform = `translate(${bracketSize - thickness}px, -${bracketSize}px)`;
            applyEffects(trVertical, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(trVertical);
            
            const trHorizontal = document.createElement('div');
            trHorizontal.style.width = lineLength + 'px';
            trHorizontal.style.height = thickness + 'px';
            trHorizontal.style.backgroundColor = color;
            trHorizontal.style.position = 'absolute';
            trHorizontal.style.top = '50%';
            trHorizontal.style.left = '50%';
            trHorizontal.style.transform = `translate(${bracketSize - lineLength}px, -${bracketSize}px)`;
            applyEffects(trHorizontal, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(trHorizontal);
            
            // Bottom-left bracket
            const blVertical = document.createElement('div');
            blVertical.style.width = thickness + 'px';
            blVertical.style.height = lineLength + 'px';
            blVertical.style.backgroundColor = color;
            blVertical.style.position = 'absolute';
            blVertical.style.top = '50%';
            blVertical.style.left = '50%';
            blVertical.style.transform = `translate(-${bracketSize}px, ${bracketSize - lineLength}px)`;
            applyEffects(blVertical, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(blVertical);
            
            const blHorizontal = document.createElement('div');
            blHorizontal.style.width = lineLength + 'px';
            blHorizontal.style.height = thickness + 'px';
            blHorizontal.style.backgroundColor = color;
            blHorizontal.style.position = 'absolute';
            blHorizontal.style.top = '50%';
            blHorizontal.style.left = '50%';
            blHorizontal.style.transform = `translate(-${bracketSize}px, ${bracketSize - thickness}px)`;
            applyEffects(blHorizontal, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(blHorizontal);
            
            // Bottom-right bracket
            const brVertical = document.createElement('div');
            brVertical.style.width = thickness + 'px';
            brVertical.style.height = lineLength + 'px';
            brVertical.style.backgroundColor = color;
            brVertical.style.position = 'absolute';
            brVertical.style.top = '50%';
            brVertical.style.left = '50%';
            brVertical.style.transform = `translate(${bracketSize - thickness}px, ${bracketSize - lineLength}px)`;
            applyEffects(brVertical, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(brVertical);
            
            const brHorizontal = document.createElement('div');
            brHorizontal.style.width = lineLength + 'px';
            brHorizontal.style.height = thickness + 'px';
            brHorizontal.style.backgroundColor = color;
            brHorizontal.style.position = 'absolute';
            brHorizontal.style.top = '50%';
            brHorizontal.style.left = '50%';
            brHorizontal.style.transform = `translate(${bracketSize - lineLength}px, ${bracketSize - thickness}px)`;
            applyEffects(brHorizontal, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(brHorizontal);
        }

        function renderHollowCircle(container, color, size, thickness, hasOutline, outlineColor = '#000000', outlineThickness = 1, shadowEnabled = false, shadowColor = '#000000', shadowBlur = 2, shadowOffsetX = 0, shadowOffsetY = 0) {
            // Outer circle
            const outerCircle = document.createElement('div');
            outerCircle.style.width = size + 'px';
            outerCircle.style.height = size + 'px';
            outerCircle.style.border = `${thickness}px solid ${color}`;
            outerCircle.style.borderRadius = '50%';
            outerCircle.style.position = 'absolute';
            outerCircle.style.top = '50%';
            outerCircle.style.left = '50%';
            outerCircle.style.transform = 'translate(-50%, -50%)';
            outerCircle.style.backgroundColor = 'transparent';
            applyEffects(outerCircle, hasOutline, outlineColor, outlineThickness, shadowEnabled, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY);
            container.appendChild(outerCircle);
            
            // Inner circle (hollow part)
            const innerSize = size * 0.5;
            const innerCircle = document.createElement('div');
            innerCircle.style.width = innerSize + 'px';
            innerCircle.style.height = innerSize + 'px';
            innerCircle.style.border = `${thickness}px solid ${color}`;
            innerCircle.style.borderRadius = '50%';
            innerCircle.style.position = 'absolute';
            innerCircle.style.top = '50%';
            innerCircle.style.left = '50%';
            innerCircle.style.transform = 'translate(-50%, -50%)';
            innerCircle.style.backgroundColor = 'transparent';
            container.appendChild(innerCircle);
        }

        function showHotkeyInfo() {
            const info = document.getElementById('hotkey-info');
            info.classList.add('show');
            setTimeout(() => {
                info.classList.remove('show');
            }, 3000);
        }

        // Listen for crosshair updates from main process
        const { ipcRenderer } = require('electron');
        
        ipcRenderer.on('update-crosshair', (event, settings) => {
            console.log('Overlay received crosshair update:', settings);
            updateCrosshair(settings);
        });

        // Initialize crosshair
        document.addEventListener('DOMContentLoaded', () => {
            renderCrosshair();
            showHotkeyInfo();
            initializeHotkeys(); // Initialize hotkey system
        });

        // Show hotkey info periodically
        setInterval(showHotkeyInfo, 30000); // Every 30 seconds
    </script>
</body>
</html>